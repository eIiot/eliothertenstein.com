// eslint-disable
// ⚠️ DO NOT EDIT ⚠️
// This file is automatically generated, run yarn run generate to update

import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
const defaultOptions = {} as const
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  DateTime: any
}

export type Comment = {
  __typename?: 'Comment'
  author: User
  content: Scalars['String']
  createdAt: Scalars['DateTime']
  id: Scalars['ID']
  postId: Scalars['String']
  updatedAt: Scalars['DateTime']
  userId: Scalars['String']
  viewerCanDelete: Scalars['Boolean']
  viewerCanEdit: Scalars['Boolean']
}

export type Mutation = {
  __typename?: 'Mutation'
  createComment?: Maybe<Comment>
  deleteComment?: Maybe<Scalars['Boolean']>
  deletePost?: Maybe<Scalars['Boolean']>
  deleteUser?: Maybe<Scalars['Boolean']>
  updateComment?: Maybe<Comment>
  upsertPost?: Maybe<Post>
  upsertUser?: Maybe<User>
}

export type MutationCreateCommentArgs = {
  content: Scalars['String']
  postId: Scalars['String']
}

export type MutationDeleteCommentArgs = {
  id: Scalars['String']
}

export type MutationDeletePostArgs = {
  slug: Scalars['String']
}

export type MutationDeleteUserArgs = {
  id: Scalars['String']
}

export type MutationUpdateCommentArgs = {
  content: Scalars['String']
  id: Scalars['String']
}

export type MutationUpsertPostArgs = {
  content?: InputMaybe<Scalars['String']>
  excerpt?: InputMaybe<Scalars['String']>
  featureImage?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['ID']>
  slug: Scalars['String']
  title?: InputMaybe<Scalars['String']>
}

export type MutationUpsertUserArgs = {
  avatar?: InputMaybe<Scalars['String']>
  description?: InputMaybe<Scalars['String']>
  email?: InputMaybe<Scalars['String']>
  githubId: Scalars['Int']
  id: Scalars['ID']
  location?: InputMaybe<Scalars['String']>
  name: Scalars['String']
  role: Role
  username: Scalars['String']
}

export type Post = {
  __typename?: 'Post'
  commentCount?: Maybe<Scalars['Int']>
  content: Scalars['String']
  createdAt: Scalars['DateTime']
  excerpt: Scalars['String']
  featureImage?: Maybe<Scalars['String']>
  id: Scalars['ID']
  publishedAt?: Maybe<Scalars['DateTime']>
  reactionCount?: Maybe<Scalars['Int']>
  slug: Scalars['String']
  title: Scalars['String']
  updatedAt: Scalars['DateTime']
}

export type Query = {
  __typename?: 'Query'
  comments?: Maybe<Array<Maybe<Comment>>>
  post?: Maybe<Post>
  posts?: Maybe<Array<Maybe<Post>>>
  user?: Maybe<User>
  viewer?: Maybe<User>
}

export type QueryCommentsArgs = {
  postId: Scalars['ID']
}

export type QueryPostArgs = {
  slug: Scalars['String']
}

export type QueryUserArgs = {
  id: Scalars['ID']
}

export type Reaction = {
  __typename?: 'Reaction'
  comment?: Maybe<Comment>
  createdAt: Scalars['DateTime']
  id: Scalars['ID']
  post?: Maybe<Post>
  postId?: Maybe<Scalars['String']>
  user: User
  userId: Scalars['String']
}

export enum Role {
  Admin = 'ADMIN',
  Blocked = 'BLOCKED',
  User = 'USER',
}

export type User = {
  __typename?: 'User'
  avatar?: Maybe<Scalars['String']>
  comments?: Maybe<Array<Maybe<Comment>>>
  createdAt: Scalars['DateTime']
  description?: Maybe<Scalars['String']>
  email?: Maybe<Scalars['String']>
  githubId: Scalars['Int']
  id: Scalars['ID']
  isAdmin?: Maybe<Scalars['Boolean']>
  isBlocked?: Maybe<Scalars['Boolean']>
  location?: Maybe<Scalars['String']>
  name: Scalars['String']
  reactions?: Maybe<Array<Maybe<Reaction>>>
  role: Role
  username: Scalars['String']
}

export type CommentDetailFragment = {
  __typename?: 'Comment'
  id: string
  createdAt: any
  updatedAt: any
  content: string
  userId: string
  postId: string
  viewerCanEdit: boolean
  viewerCanDelete: boolean
  author: {
    __typename?: 'User'
    id: string
    role: Role
    createdAt: any
    username: string
    githubId: number
    name: string
    avatar?: string | null
  }
}

export type PostCoreFragment = {
  __typename?: 'Post'
  id: string
  createdAt: any
  updatedAt: any
  publishedAt?: any | null
  slug: string
  title: string
  content: string
  excerpt: string
  featureImage?: string | null
  reactionCount?: number | null
  commentCount?: number | null
}

export type ReactionDetailFragment = {
  __typename?: 'Reaction'
  id: string
  createdAt: any
}

export type UserDetailFragment = {
  __typename?: 'User'
  id: string
  role: Role
  createdAt: any
  username: string
  githubId: number
  name: string
  avatar?: string | null
}

export type CreateCommentMutationVariables = Exact<{
  content: Scalars['String']
  postId: Scalars['String']
}>

export type CreateCommentMutation = {
  __typename?: 'Mutation'
  createComment?: {
    __typename?: 'Comment'
    id: string
    createdAt: any
    updatedAt: any
    content: string
    userId: string
    postId: string
    viewerCanEdit: boolean
    viewerCanDelete: boolean
    author: {
      __typename?: 'User'
      id: string
      role: Role
      createdAt: any
      username: string
      githubId: number
      name: string
      avatar?: string | null
    }
  } | null
}

export type UpdateCommentMutationVariables = Exact<{
  content: Scalars['String']
  id: Scalars['String']
}>

export type UpdateCommentMutation = {
  __typename?: 'Mutation'
  updateComment?: {
    __typename?: 'Comment'
    id: string
    createdAt: any
    updatedAt: any
    content: string
    userId: string
    postId: string
    viewerCanEdit: boolean
    viewerCanDelete: boolean
    author: {
      __typename?: 'User'
      id: string
      role: Role
      createdAt: any
      username: string
      githubId: number
      name: string
      avatar?: string | null
    }
  } | null
}

export type DeleteCommentMutationVariables = Exact<{
  id: Scalars['String']
}>

export type DeleteCommentMutation = {
  __typename?: 'Mutation'
  deleteComment?: boolean | null
}

export type UpsertPostMutationVariables = Exact<{
  title?: InputMaybe<Scalars['String']>
  content?: InputMaybe<Scalars['String']>
  slug: Scalars['String']
  excerpt?: InputMaybe<Scalars['String']>
  featureImage?: InputMaybe<Scalars['String']>
}>

export type UpsertPostMutation = {
  __typename?: 'Mutation'
  upsertPost?: {
    __typename?: 'Post'
    id: string
    createdAt: any
    updatedAt: any
    publishedAt?: any | null
    slug: string
    title: string
    content: string
    excerpt: string
    featureImage?: string | null
    reactionCount?: number | null
    commentCount?: number | null
  } | null
}

export type DeletePostMutationVariables = Exact<{
  slug: Scalars['String']
}>

export type DeletePostMutation = {
  __typename?: 'Mutation'
  deletePost?: boolean | null
}

export type UpsertUserMutationVariables = Exact<{
  id: Scalars['ID']
  role: Role
  username: Scalars['String']
  githubId: Scalars['Int']
  email?: InputMaybe<Scalars['String']>
  avatar?: InputMaybe<Scalars['String']>
  description?: InputMaybe<Scalars['String']>
  location?: InputMaybe<Scalars['String']>
  name: Scalars['String']
}>

export type UpsertUserMutation = {
  __typename?: 'Mutation'
  upsertUser?: {
    __typename?: 'User'
    id: string
    role: Role
    createdAt: any
    username: string
    githubId: number
    name: string
    avatar?: string | null
  } | null
}

export type DeleteUserMutationVariables = Exact<{
  id: Scalars['String']
}>

export type DeleteUserMutation = {
  __typename?: 'Mutation'
  deleteUser?: boolean | null
}

export type GetCommentsQueryVariables = Exact<{
  postId: Scalars['ID']
}>

export type GetCommentsQuery = {
  __typename?: 'Query'
  comments?: Array<{
    __typename?: 'Comment'
    id: string
    createdAt: any
    updatedAt: any
    content: string
    userId: string
    postId: string
    viewerCanEdit: boolean
    viewerCanDelete: boolean
    author: {
      __typename?: 'User'
      id: string
      role: Role
      createdAt: any
      username: string
      githubId: number
      name: string
      avatar?: string | null
    }
  } | null> | null
}

export type GetPostQueryVariables = Exact<{
  slug: Scalars['String']
}>

export type GetPostQuery = {
  __typename?: 'Query'
  post?: {
    __typename?: 'Post'
    id: string
    createdAt: any
    updatedAt: any
    publishedAt?: any | null
    slug: string
    title: string
    content: string
    excerpt: string
    featureImage?: string | null
    reactionCount?: number | null
    commentCount?: number | null
  } | null
}

export type GetPostsQueryVariables = Exact<{ [key: string]: never }>

export type GetPostsQuery = {
  __typename?: 'Query'
  posts?: Array<{
    __typename?: 'Post'
    id: string
    createdAt: any
    updatedAt: any
    publishedAt?: any | null
    slug: string
    title: string
    content: string
    excerpt: string
    featureImage?: string | null
    reactionCount?: number | null
    commentCount?: number | null
  } | null> | null
}

export type GetUserQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type GetUserQuery = {
  __typename?: 'Query'
  user?: {
    __typename?: 'User'
    id: string
    role: Role
    createdAt: any
    username: string
    githubId: number
    name: string
    avatar?: string | null
  } | null
}

export type GetViewerQueryVariables = Exact<{ [key: string]: never }>

export type GetViewerQuery = {
  __typename?: 'Query'
  viewer?: {
    __typename?: 'User'
    isAdmin?: boolean | null
    isBlocked?: boolean | null
    id: string
    role: Role
    createdAt: any
    username: string
    githubId: number
    name: string
    avatar?: string | null
  } | null
}

export const UserDetailFragmentDoc = gql`
  fragment UserDetail on User {
    id
    role
    createdAt
    username
    githubId
    name
    avatar
  }
`
export const CommentDetailFragmentDoc = gql`
  fragment CommentDetail on Comment {
    id
    createdAt
    updatedAt
    content
    userId
    postId
    author {
      ...UserDetail
    }
    viewerCanEdit
    viewerCanDelete
  }
  ${UserDetailFragmentDoc}
`
export const PostCoreFragmentDoc = gql`
  fragment PostCore on Post {
    id
    createdAt
    updatedAt
    publishedAt
    slug
    title
    content
    excerpt
    featureImage
    reactionCount
    commentCount
  }
`
export const ReactionDetailFragmentDoc = gql`
  fragment ReactionDetail on Reaction {
    id
    createdAt
  }
`
export const CreateCommentDocument = gql`
  mutation createComment($content: String!, $postId: String!) {
    createComment(content: $content, postId: $postId) {
      ...CommentDetail
    }
  }
  ${CommentDetailFragmentDoc}
`
export type CreateCommentMutationFn = Apollo.MutationFunction<
  CreateCommentMutation,
  CreateCommentMutationVariables
>

/**
 * __useCreateCommentMutation__
 *
 * To run a mutation, you first call `useCreateCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCommentMutation, { data, loading, error }] = useCreateCommentMutation({
 *   variables: {
 *      content: // value for 'content'
 *      postId: // value for 'postId'
 *   },
 * });
 */
export function useCreateCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateCommentMutation,
    CreateCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    CreateCommentMutation,
    CreateCommentMutationVariables
  >(CreateCommentDocument, options)
}
export type CreateCommentMutationHookResult = ReturnType<
  typeof useCreateCommentMutation
>
export type CreateCommentMutationResult =
  Apollo.MutationResult<CreateCommentMutation>
export type CreateCommentMutationOptions = Apollo.BaseMutationOptions<
  CreateCommentMutation,
  CreateCommentMutationVariables
>
export const UpdateCommentDocument = gql`
  mutation updateComment($content: String!, $id: String!) {
    updateComment(content: $content, id: $id) {
      ...CommentDetail
    }
  }
  ${CommentDetailFragmentDoc}
`
export type UpdateCommentMutationFn = Apollo.MutationFunction<
  UpdateCommentMutation,
  UpdateCommentMutationVariables
>

/**
 * __useUpdateCommentMutation__
 *
 * To run a mutation, you first call `useUpdateCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCommentMutation, { data, loading, error }] = useUpdateCommentMutation({
 *   variables: {
 *      content: // value for 'content'
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUpdateCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateCommentMutation,
    UpdateCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    UpdateCommentMutation,
    UpdateCommentMutationVariables
  >(UpdateCommentDocument, options)
}
export type UpdateCommentMutationHookResult = ReturnType<
  typeof useUpdateCommentMutation
>
export type UpdateCommentMutationResult =
  Apollo.MutationResult<UpdateCommentMutation>
export type UpdateCommentMutationOptions = Apollo.BaseMutationOptions<
  UpdateCommentMutation,
  UpdateCommentMutationVariables
>
export const DeleteCommentDocument = gql`
  mutation deleteComment($id: String!) {
    deleteComment(id: $id)
  }
`
export type DeleteCommentMutationFn = Apollo.MutationFunction<
  DeleteCommentMutation,
  DeleteCommentMutationVariables
>

/**
 * __useDeleteCommentMutation__
 *
 * To run a mutation, you first call `useDeleteCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCommentMutation, { data, loading, error }] = useDeleteCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteCommentMutation,
    DeleteCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteCommentMutation,
    DeleteCommentMutationVariables
  >(DeleteCommentDocument, options)
}
export type DeleteCommentMutationHookResult = ReturnType<
  typeof useDeleteCommentMutation
>
export type DeleteCommentMutationResult =
  Apollo.MutationResult<DeleteCommentMutation>
export type DeleteCommentMutationOptions = Apollo.BaseMutationOptions<
  DeleteCommentMutation,
  DeleteCommentMutationVariables
>
export const UpsertPostDocument = gql`
  mutation upsertPost(
    $title: String
    $content: String
    $slug: String!
    $excerpt: String
    $featureImage: String
  ) {
    upsertPost(
      title: $title
      content: $content
      slug: $slug
      excerpt: $excerpt
      featureImage: $featureImage
    ) {
      ...PostCore
    }
  }
  ${PostCoreFragmentDoc}
`
export type UpsertPostMutationFn = Apollo.MutationFunction<
  UpsertPostMutation,
  UpsertPostMutationVariables
>

/**
 * __useUpsertPostMutation__
 *
 * To run a mutation, you first call `useUpsertPostMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertPostMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertPostMutation, { data, loading, error }] = useUpsertPostMutation({
 *   variables: {
 *      title: // value for 'title'
 *      content: // value for 'content'
 *      slug: // value for 'slug'
 *      excerpt: // value for 'excerpt'
 *      featureImage: // value for 'featureImage'
 *   },
 * });
 */
export function useUpsertPostMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpsertPostMutation,
    UpsertPostMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpsertPostMutation, UpsertPostMutationVariables>(
    UpsertPostDocument,
    options
  )
}
export type UpsertPostMutationHookResult = ReturnType<
  typeof useUpsertPostMutation
>
export type UpsertPostMutationResult = Apollo.MutationResult<UpsertPostMutation>
export type UpsertPostMutationOptions = Apollo.BaseMutationOptions<
  UpsertPostMutation,
  UpsertPostMutationVariables
>
export const DeletePostDocument = gql`
  mutation deletePost($slug: String!) {
    deletePost(slug: $slug)
  }
`
export type DeletePostMutationFn = Apollo.MutationFunction<
  DeletePostMutation,
  DeletePostMutationVariables
>

/**
 * __useDeletePostMutation__
 *
 * To run a mutation, you first call `useDeletePostMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePostMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePostMutation, { data, loading, error }] = useDeletePostMutation({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useDeletePostMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeletePostMutation,
    DeletePostMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeletePostMutation, DeletePostMutationVariables>(
    DeletePostDocument,
    options
  )
}
export type DeletePostMutationHookResult = ReturnType<
  typeof useDeletePostMutation
>
export type DeletePostMutationResult = Apollo.MutationResult<DeletePostMutation>
export type DeletePostMutationOptions = Apollo.BaseMutationOptions<
  DeletePostMutation,
  DeletePostMutationVariables
>
export const UpsertUserDocument = gql`
  mutation upsertUser(
    $id: ID!
    $role: Role!
    $username: String!
    $githubId: Int!
    $email: String
    $avatar: String
    $description: String
    $location: String
    $name: String!
  ) {
    upsertUser(
      id: $id
      role: $role
      username: $username
      githubId: $githubId
      email: $email
      avatar: $avatar
      description: $description
      location: $location
      name: $name
    ) {
      ...UserDetail
    }
  }
  ${UserDetailFragmentDoc}
`
export type UpsertUserMutationFn = Apollo.MutationFunction<
  UpsertUserMutation,
  UpsertUserMutationVariables
>

/**
 * __useUpsertUserMutation__
 *
 * To run a mutation, you first call `useUpsertUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertUserMutation, { data, loading, error }] = useUpsertUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *      role: // value for 'role'
 *      username: // value for 'username'
 *      githubId: // value for 'githubId'
 *      email: // value for 'email'
 *      avatar: // value for 'avatar'
 *      description: // value for 'description'
 *      location: // value for 'location'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useUpsertUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpsertUserMutation,
    UpsertUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpsertUserMutation, UpsertUserMutationVariables>(
    UpsertUserDocument,
    options
  )
}
export type UpsertUserMutationHookResult = ReturnType<
  typeof useUpsertUserMutation
>
export type UpsertUserMutationResult = Apollo.MutationResult<UpsertUserMutation>
export type UpsertUserMutationOptions = Apollo.BaseMutationOptions<
  UpsertUserMutation,
  UpsertUserMutationVariables
>
export const DeleteUserDocument = gql`
  mutation deleteUser($id: String!) {
    deleteUser(id: $id)
  }
`
export type DeleteUserMutationFn = Apollo.MutationFunction<
  DeleteUserMutation,
  DeleteUserMutationVariables
>

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteUserMutation,
    DeleteUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(
    DeleteUserDocument,
    options
  )
}
export type DeleteUserMutationHookResult = ReturnType<
  typeof useDeleteUserMutation
>
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<
  DeleteUserMutation,
  DeleteUserMutationVariables
>
export const GetCommentsDocument = gql`
  query getComments($postId: ID!) {
    comments(postId: $postId) {
      ...CommentDetail
    }
  }
  ${CommentDetailFragmentDoc}
`

/**
 * __useGetCommentsQuery__
 *
 * To run a query within a React component, call `useGetCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCommentsQuery({
 *   variables: {
 *      postId: // value for 'postId'
 *   },
 * });
 */
export function useGetCommentsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetCommentsQuery,
    GetCommentsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetCommentsQuery, GetCommentsQueryVariables>(
    GetCommentsDocument,
    options
  )
}
export function useGetCommentsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetCommentsQuery,
    GetCommentsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetCommentsQuery, GetCommentsQueryVariables>(
    GetCommentsDocument,
    options
  )
}
export type GetCommentsQueryHookResult = ReturnType<typeof useGetCommentsQuery>
export type GetCommentsLazyQueryHookResult = ReturnType<
  typeof useGetCommentsLazyQuery
>
export type GetCommentsQueryResult = Apollo.QueryResult<
  GetCommentsQuery,
  GetCommentsQueryVariables
>
export const GetPostDocument = gql`
  query getPost($slug: String!) {
    post(slug: $slug) {
      ...PostCore
    }
  }
  ${PostCoreFragmentDoc}
`

/**
 * __useGetPostQuery__
 *
 * To run a query within a React component, call `useGetPostQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useGetPostQuery(
  baseOptions: Apollo.QueryHookOptions<GetPostQuery, GetPostQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export function useGetPostLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetPostQuery, GetPostQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export type GetPostQueryHookResult = ReturnType<typeof useGetPostQuery>
export type GetPostLazyQueryHookResult = ReturnType<typeof useGetPostLazyQuery>
export type GetPostQueryResult = Apollo.QueryResult<
  GetPostQuery,
  GetPostQueryVariables
>
export const GetPostsDocument = gql`
  query getPosts {
    posts {
      ...PostCore
    }
  }
  ${PostCoreFragmentDoc}
`

/**
 * __useGetPostsQuery__
 *
 * To run a query within a React component, call `useGetPostsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPostsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetPostsQuery, GetPostsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export function useGetPostsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetPostsQuery,
    GetPostsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export type GetPostsQueryHookResult = ReturnType<typeof useGetPostsQuery>
export type GetPostsLazyQueryHookResult = ReturnType<
  typeof useGetPostsLazyQuery
>
export type GetPostsQueryResult = Apollo.QueryResult<
  GetPostsQuery,
  GetPostsQueryVariables
>
export const GetUserDocument = gql`
  query getUser($id: ID!) {
    user(id: $id) {
      ...UserDetail
    }
  }
  ${UserDetailFragmentDoc}
`

/**
 * __useGetUserQuery__
 *
 * To run a query within a React component, call `useGetUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserQuery(
  baseOptions: Apollo.QueryHookOptions<GetUserQuery, GetUserQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export function useGetUserLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetUserQuery, GetUserQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export type GetUserQueryHookResult = ReturnType<typeof useGetUserQuery>
export type GetUserLazyQueryHookResult = ReturnType<typeof useGetUserLazyQuery>
export type GetUserQueryResult = Apollo.QueryResult<
  GetUserQuery,
  GetUserQueryVariables
>
export const GetViewerDocument = gql`
  query getViewer {
    viewer {
      ...UserDetail
      isAdmin
      isBlocked
    }
  }
  ${UserDetailFragmentDoc}
`

/**
 * __useGetViewerQuery__
 *
 * To run a query within a React component, call `useGetViewerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetViewerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetViewerQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetViewerQuery(
  baseOptions?: Apollo.QueryHookOptions<GetViewerQuery, GetViewerQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetViewerQuery, GetViewerQueryVariables>(
    GetViewerDocument,
    options
  )
}
export function useGetViewerLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetViewerQuery,
    GetViewerQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetViewerQuery, GetViewerQueryVariables>(
    GetViewerDocument,
    options
  )
}
export type GetViewerQueryHookResult = ReturnType<typeof useGetViewerQuery>
export type GetViewerLazyQueryHookResult = ReturnType<
  typeof useGetViewerLazyQuery
>
export type GetViewerQueryResult = Apollo.QueryResult<
  GetViewerQuery,
  GetViewerQueryVariables
>
