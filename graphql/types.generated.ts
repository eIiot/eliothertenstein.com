// eslint-disable
// ⚠️ DO NOT EDIT ⚠️
// This file is automatically generated, run yarn run generate to update

import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
const defaultOptions = {} as const
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  DateTime: any
}

export type Mutation = {
  __typename?: 'Mutation'
  deletePost?: Maybe<Post>
  deleteUser?: Maybe<User>
  upsertPost?: Maybe<Post>
  upsertUser?: Maybe<User>
}

export type MutationDeletePostArgs = {
  slug: Scalars['String']
}

export type MutationDeleteUserArgs = {
  id: Scalars['String']
}

export type MutationUpsertPostArgs = {
  content?: InputMaybe<Scalars['String']>
  excerpt?: InputMaybe<Scalars['String']>
  featureImage?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['ID']>
  slug: Scalars['String']
  title?: InputMaybe<Scalars['String']>
}

export type MutationUpsertUserArgs = {
  avatar?: InputMaybe<Scalars['String']>
  description?: InputMaybe<Scalars['String']>
  email?: InputMaybe<Scalars['String']>
  githubId: Scalars['Int']
  id: Scalars['ID']
  location?: InputMaybe<Scalars['String']>
  name: Scalars['String']
  role: Role
  username: Scalars['String']
}

export type Post = {
  __typename?: 'Post'
  content: Scalars['String']
  createdAt: Scalars['DateTime']
  excerpt?: Maybe<Scalars['String']>
  featureImage?: Maybe<Scalars['String']>
  id: Scalars['ID']
  publishedAt?: Maybe<Scalars['DateTime']>
  slug: Scalars['String']
  title: Scalars['String']
  updatedAt: Scalars['DateTime']
}

export type Query = {
  __typename?: 'Query'
  post?: Maybe<Post>
  posts?: Maybe<Array<Maybe<Post>>>
  user?: Maybe<User>
}

export type QueryPostArgs = {
  slug: Scalars['String']
}

export type QueryUserArgs = {
  id: Scalars['ID']
}

export enum Role {
  Admin = 'ADMIN',
  Blocked = 'BLOCKED',
  User = 'USER',
}

export type User = {
  __typename?: 'User'
  avatar?: Maybe<Scalars['String']>
  createdAt: Scalars['DateTime']
  description?: Maybe<Scalars['String']>
  email?: Maybe<Scalars['String']>
  githubId: Scalars['Int']
  id: Scalars['ID']
  location?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  role: Role
  updatedAt: Scalars['DateTime']
  username: Scalars['String']
}

export type PostFragmentFragment = {
  __typename?: 'Post'
  id: string
  createdAt: any
  updatedAt: any
  publishedAt?: any | null
  slug: string
  title: string
  content: string
  excerpt?: string | null
  featureImage?: string | null
}

export type UserFragmentFragment = {
  __typename?: 'User'
  id: string
  role: Role
  username: string
  githubId: number
  email?: string | null
  avatar?: string | null
  description?: string | null
  location?: string | null
  name?: string | null
}

export type UpsertPostMutationVariables = Exact<{
  title?: InputMaybe<Scalars['String']>
  content?: InputMaybe<Scalars['String']>
  slug: Scalars['String']
  excerpt?: InputMaybe<Scalars['String']>
  featureImage?: InputMaybe<Scalars['String']>
}>

export type UpsertPostMutation = {
  __typename?: 'Mutation'
  upsertPost?: {
    __typename?: 'Post'
    id: string
    createdAt: any
    updatedAt: any
    publishedAt?: any | null
    slug: string
    title: string
    content: string
    excerpt?: string | null
    featureImage?: string | null
  } | null
}

export type DeletePostMutationVariables = Exact<{
  slug: Scalars['String']
}>

export type DeletePostMutation = {
  __typename?: 'Mutation'
  deletePost?: {
    __typename?: 'Post'
    id: string
    createdAt: any
    updatedAt: any
    publishedAt?: any | null
    slug: string
    title: string
    content: string
    excerpt?: string | null
    featureImage?: string | null
  } | null
}

export type UpsertUserMutationVariables = Exact<{
  id: Scalars['ID']
  role: Role
  username: Scalars['String']
  githubId: Scalars['Int']
  email?: InputMaybe<Scalars['String']>
  avatar?: InputMaybe<Scalars['String']>
  description?: InputMaybe<Scalars['String']>
  location?: InputMaybe<Scalars['String']>
  name: Scalars['String']
}>

export type UpsertUserMutation = {
  __typename?: 'Mutation'
  upsertUser?: {
    __typename?: 'User'
    id: string
    role: Role
    username: string
    githubId: number
    email?: string | null
    avatar?: string | null
    description?: string | null
    location?: string | null
    name?: string | null
  } | null
}

export type DeleteUserMutationVariables = Exact<{
  id: Scalars['String']
}>

export type DeleteUserMutation = {
  __typename?: 'Mutation'
  deleteUser?: {
    __typename?: 'User'
    id: string
    role: Role
    username: string
    githubId: number
    email?: string | null
    avatar?: string | null
    description?: string | null
    location?: string | null
    name?: string | null
  } | null
}

export type GetPostQueryVariables = Exact<{
  slug: Scalars['String']
}>

export type GetPostQuery = {
  __typename?: 'Query'
  post?: {
    __typename?: 'Post'
    id: string
    createdAt: any
    updatedAt: any
    publishedAt?: any | null
    slug: string
    title: string
    content: string
    excerpt?: string | null
    featureImage?: string | null
  } | null
}

export type GetPostsQueryVariables = Exact<{ [key: string]: never }>

export type GetPostsQuery = {
  __typename?: 'Query'
  posts?: Array<{
    __typename?: 'Post'
    id: string
    createdAt: any
    updatedAt: any
    publishedAt?: any | null
    slug: string
    title: string
    content: string
    excerpt?: string | null
    featureImage?: string | null
  } | null> | null
}

export type GetUserQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type GetUserQuery = {
  __typename?: 'Query'
  user?: {
    __typename?: 'User'
    id: string
    role: Role
    username: string
    githubId: number
    email?: string | null
    avatar?: string | null
    description?: string | null
    location?: string | null
    name?: string | null
  } | null
}

export const PostFragmentFragmentDoc = gql`
  fragment PostFragment on Post {
    id
    createdAt
    updatedAt
    publishedAt
    slug
    title
    content
    excerpt
    featureImage
  }
`
export const UserFragmentFragmentDoc = gql`
  fragment UserFragment on User {
    id
    role
    username
    githubId
    email
    avatar
    description
    location
    name
  }
`
export const UpsertPostDocument = gql`
  mutation upsertPost(
    $title: String
    $content: String
    $slug: String!
    $excerpt: String
    $featureImage: String
  ) {
    upsertPost(
      title: $title
      content: $content
      slug: $slug
      excerpt: $excerpt
      featureImage: $featureImage
    ) {
      ...PostFragment
    }
  }
  ${PostFragmentFragmentDoc}
`
export type UpsertPostMutationFn = Apollo.MutationFunction<
  UpsertPostMutation,
  UpsertPostMutationVariables
>

/**
 * __useUpsertPostMutation__
 *
 * To run a mutation, you first call `useUpsertPostMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertPostMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertPostMutation, { data, loading, error }] = useUpsertPostMutation({
 *   variables: {
 *      title: // value for 'title'
 *      content: // value for 'content'
 *      slug: // value for 'slug'
 *      excerpt: // value for 'excerpt'
 *      featureImage: // value for 'featureImage'
 *   },
 * });
 */
export function useUpsertPostMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpsertPostMutation,
    UpsertPostMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpsertPostMutation, UpsertPostMutationVariables>(
    UpsertPostDocument,
    options
  )
}
export type UpsertPostMutationHookResult = ReturnType<
  typeof useUpsertPostMutation
>
export type UpsertPostMutationResult = Apollo.MutationResult<UpsertPostMutation>
export type UpsertPostMutationOptions = Apollo.BaseMutationOptions<
  UpsertPostMutation,
  UpsertPostMutationVariables
>
export const DeletePostDocument = gql`
  mutation deletePost($slug: String!) {
    deletePost(slug: $slug) {
      ...PostFragment
    }
  }
  ${PostFragmentFragmentDoc}
`
export type DeletePostMutationFn = Apollo.MutationFunction<
  DeletePostMutation,
  DeletePostMutationVariables
>

/**
 * __useDeletePostMutation__
 *
 * To run a mutation, you first call `useDeletePostMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePostMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePostMutation, { data, loading, error }] = useDeletePostMutation({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useDeletePostMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeletePostMutation,
    DeletePostMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeletePostMutation, DeletePostMutationVariables>(
    DeletePostDocument,
    options
  )
}
export type DeletePostMutationHookResult = ReturnType<
  typeof useDeletePostMutation
>
export type DeletePostMutationResult = Apollo.MutationResult<DeletePostMutation>
export type DeletePostMutationOptions = Apollo.BaseMutationOptions<
  DeletePostMutation,
  DeletePostMutationVariables
>
export const UpsertUserDocument = gql`
  mutation upsertUser(
    $id: ID!
    $role: Role!
    $username: String!
    $githubId: Int!
    $email: String
    $avatar: String
    $description: String
    $location: String
    $name: String!
  ) {
    upsertUser(
      id: $id
      role: $role
      username: $username
      githubId: $githubId
      email: $email
      avatar: $avatar
      description: $description
      location: $location
      name: $name
    ) {
      ...UserFragment
    }
  }
  ${UserFragmentFragmentDoc}
`
export type UpsertUserMutationFn = Apollo.MutationFunction<
  UpsertUserMutation,
  UpsertUserMutationVariables
>

/**
 * __useUpsertUserMutation__
 *
 * To run a mutation, you first call `useUpsertUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertUserMutation, { data, loading, error }] = useUpsertUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *      role: // value for 'role'
 *      username: // value for 'username'
 *      githubId: // value for 'githubId'
 *      email: // value for 'email'
 *      avatar: // value for 'avatar'
 *      description: // value for 'description'
 *      location: // value for 'location'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useUpsertUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpsertUserMutation,
    UpsertUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpsertUserMutation, UpsertUserMutationVariables>(
    UpsertUserDocument,
    options
  )
}
export type UpsertUserMutationHookResult = ReturnType<
  typeof useUpsertUserMutation
>
export type UpsertUserMutationResult = Apollo.MutationResult<UpsertUserMutation>
export type UpsertUserMutationOptions = Apollo.BaseMutationOptions<
  UpsertUserMutation,
  UpsertUserMutationVariables
>
export const DeleteUserDocument = gql`
  mutation deleteUser($id: String!) {
    deleteUser(id: $id) {
      ...UserFragment
    }
  }
  ${UserFragmentFragmentDoc}
`
export type DeleteUserMutationFn = Apollo.MutationFunction<
  DeleteUserMutation,
  DeleteUserMutationVariables
>

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteUserMutation,
    DeleteUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(
    DeleteUserDocument,
    options
  )
}
export type DeleteUserMutationHookResult = ReturnType<
  typeof useDeleteUserMutation
>
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<
  DeleteUserMutation,
  DeleteUserMutationVariables
>
export const GetPostDocument = gql`
  query getPost($slug: String!) {
    post(slug: $slug) {
      ...PostFragment
    }
  }
  ${PostFragmentFragmentDoc}
`

/**
 * __useGetPostQuery__
 *
 * To run a query within a React component, call `useGetPostQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useGetPostQuery(
  baseOptions: Apollo.QueryHookOptions<GetPostQuery, GetPostQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export function useGetPostLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetPostQuery, GetPostQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export type GetPostQueryHookResult = ReturnType<typeof useGetPostQuery>
export type GetPostLazyQueryHookResult = ReturnType<typeof useGetPostLazyQuery>
export type GetPostQueryResult = Apollo.QueryResult<
  GetPostQuery,
  GetPostQueryVariables
>
export const GetPostsDocument = gql`
  query getPosts {
    posts {
      ...PostFragment
    }
  }
  ${PostFragmentFragmentDoc}
`

/**
 * __useGetPostsQuery__
 *
 * To run a query within a React component, call `useGetPostsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPostsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetPostsQuery, GetPostsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export function useGetPostsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetPostsQuery,
    GetPostsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export type GetPostsQueryHookResult = ReturnType<typeof useGetPostsQuery>
export type GetPostsLazyQueryHookResult = ReturnType<
  typeof useGetPostsLazyQuery
>
export type GetPostsQueryResult = Apollo.QueryResult<
  GetPostsQuery,
  GetPostsQueryVariables
>
export const GetUserDocument = gql`
  query getUser($id: ID!) {
    user(id: $id) {
      ...UserFragment
    }
  }
  ${UserFragmentFragmentDoc}
`

/**
 * __useGetUserQuery__
 *
 * To run a query within a React component, call `useGetUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserQuery(
  baseOptions: Apollo.QueryHookOptions<GetUserQuery, GetUserQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export function useGetUserLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetUserQuery, GetUserQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export type GetUserQueryHookResult = ReturnType<typeof useGetUserQuery>
export type GetUserLazyQueryHookResult = ReturnType<typeof useGetUserLazyQuery>
export type GetUserQueryResult = Apollo.QueryResult<
  GetUserQuery,
  GetUserQueryVariables
>
